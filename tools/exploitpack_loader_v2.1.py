import subprocess
import http.server
import ssl
import datetime
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption

print("369 Exploit Pack POC Server/Loader - run as SUDO!")

# Generate a private key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)

# Create a certificate subject
subject = x509.Name([
    x509.NameAttribute(NameOID.COMMON_NAME, u'exploitpack.com'),
    x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u'California'),
    x509.NameAttribute(NameOID.LOCALITY_NAME, u'San Francisco'),
    x509.NameAttribute(NameOID.COUNTRY_NAME, u'US'),
])

# Define the entries to add to /etc/hosts
entries = [
    "127.0.0.1 exploitpack.com",
    "127.0.0.1 www.exploitpack.com",
]

# Read the existing /etc/hosts file
with open('/etc/hosts', 'r') as hosts_file:
    existing_entries = hosts_file.readlines()

# Check if each entry already exists in /etc/hosts
entries_to_add = []
for entry in entries:
    if entry.strip() + '\n' not in existing_entries:
        entries_to_add.append(entry)

# Open /etc/hosts in append mode and write the entries
if entries_to_add:
    with open('/etc/hosts', 'a') as hosts_file:
        for entry in entries_to_add:
            hosts_file.write(entry + '\n')
    
    print("Entries added to /etc/hosts.")
else:
    print("Entries already exist in /etc/hosts.")


# Create a self-signed certificate
cert = x509.CertificateBuilder().subject_name(
    subject
).issuer_name(
    subject
).public_key(
    private_key.public_key()
).serial_number(
    x509.random_serial_number()
).not_valid_before(
    datetime.datetime.utcnow()
).not_valid_after(
    datetime.datetime.utcnow() + datetime.timedelta(days=365)
).sign(
    private_key, hashes.SHA256(), default_backend()
)

# Save the private key and certificate to files
with open('key.pem', 'wb') as key_file:
    key_file.write(private_key.private_bytes(
        encoding=Encoding.PEM,
        format=PrivateFormat.PKCS8,
        encryption_algorithm=NoEncryption()
    ))

with open('crt.pem', 'wb') as cert_file:
    cert_file.write(cert.public_bytes(Encoding.PEM))

# Import the certificate into the Java keystore
def import_certificate():
    try:
        # Define the keytool command
        keytool_cmd = [
            'keytool',
            '-import',
            '-alias',
            'exploitpack',
            '-keystore',
            'cacerts',  # Change this to the correct keystore path if necessary
            '-file',
            'crt.pem',
            '-storepass',
            'changeit',  # Change this to the keystore password if necessary
            '-trustcacerts',
            '-noprompt',
        ]

        # Execute the keytool command
        subprocess.run(keytool_cmd, check=True)

        print("Certificate imported successfully.")
    except subprocess.CalledProcessError as e:
        print(f"Error importing certificate: {e}")

# Import the certificate
import_certificate()

file_content = b"\n"
appversion = b"17.07\n"

# Start an HTTPS server
class MyRequestHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/changelog/public':
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(file_content)
        elif self.path == '/changelog/appversion':
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(appversion)
        else:
            super().do_GET()


server_address = ('localhost', 443)
httpd = http.server.HTTPServer(server_address, MyRequestHandler)

httpd.socket = ssl.wrap_socket(httpd.socket, keyfile="key.pem", certfile="crt.pem", server_side=True)

print("Server running at https://localhost:443/")
httpd.serve_forever()

# Execute ExploitPack.jar
try:
    jar_file = "ExploitPack.jar"  # Replace with the actual JAR file path
    java_cmd = ["java", "-jar", jar_file]
    subprocess.run(java_cmd, check=True)
except subprocess.CalledProcessError as e:
    print(f"Error running the JAR file: {e}")
